## ✅ 1. flatMap 개념 및 활용

### 실습 문제

* 문자열 리스트 `["a,b,c", "d,e", "f"]` 를 `split`한 뒤, 모든 원소를 하나의 리스트로 펼쳐보세요.
* `List<List<Integer>>` 구조에서 모든 숫자를 하나의 `List<Integer>`로 합쳐보세요.
* 객체 리스트에서 각 객체가 가진 `List<String>` 필드를 flatMap으로 모두 합쳐보세요.

#### ✏️ 추가 미션

* `Optional<Optional<String>>`를 flatMap으로 풀어서 값만 꺼내 출력해보세요.

---

## ✅ 2. Stream + Optional 혼용

### 실습 문제

* 문자열 리스트에 `null`이 포함된 경우, `Optional`로 감싸서 안전하게 처리하고 길이를 출력해보세요.
* 객체 리스트에서 특정 필드가 `null`일 수 있을 때, `map` + `Optional`을 이용해 안전하게 가져오고 출력해보세요.
* Stream 처리 중 중간 단계에서 `Optional`을 어떻게 활용하면 안전하게 이어갈 수 있을지 시도해보세요.

#### ✏️ 추가 미션

* Stream으로 사용자 리스트를 순회하면서, `Optional`로 감싼 이메일을 가져와 비어있지 않은 이메일만 출력해보세요.

---

## ✅ 3. 병렬 스트림 개념과 유의점

### 실습 문제

* 숫자 리스트를 `parallelStream()`으로 합계를 구해보세요.
* `forEachOrdered`와 `forEach` 차이를 비교해보고, 출력 순서를 확인해보세요.
* 병렬 스트림에서 `peek`를 이용해 현재 어떤 스레드가 처리 중인지 출력해보세요.

#### ✏️ 추가 미션

* 공유된 변수(예: 리스트)에 병렬 스트림을 이용해 값을 추가했을 때 생기는 문제를 실험해보세요.

---

## ✅ 4. 성능 측정과 최적화

### 실습 문제

* `System.nanoTime()` 또는 `Instant.now()`를 이용해 Stream과 반복문(for) 처리 시간을 비교해보세요.
* 큰 데이터(예: 10만 개의 숫자) 처리 시, `stream`과 `parallelStream`의 속도를 측정해보세요.
* `filter → map`과 `map → filter` 순서에 따라 성능 차이를 테스트해보세요.

#### ✏️ 추가 미션

* `Collectors.toList()` 대신 `toCollection(LinkedList::new)`를 써서 구조별 성능을 비교해보세요.
* 불필요한 `sorted`를 제거해서 속도를 개선해보세요.